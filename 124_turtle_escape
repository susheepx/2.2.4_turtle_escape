import turtle as t
import random as r
import time as time

#----------variables----------

#maze configuration variables
num_walls = 22
pen_color = "black"
path_width = 25
current_wall_len = 0

#door and barriers variables
door_len = path_width*2
door = 0
barrier = 0

#--------initialization----------

t.hideturtle()
#initialize maze drawing turtle
maze_turtle = t.Turtle()
maze_turtle.pensize(4)
maze_turtle.speed('fastest')
maze_turtle.pencolor(pen_color)
maze_turtle.hideturtle()
maze_turtle.penup()
maze_turtle.goto(-path_width*2, - path_width*3)

#initalize maze runner
maze_runner = t.Turtle()
maze_runner.shape('turtle')
maze_runner.speed(3)
maze_runner.pencolor("green")
maze_runner.color("green")
maze_runner.pendown()


#----------functions----------

#set maze_runner setheading direction in all 4 directions
def right():
    maze_runner.setheading(0)
def up():
    maze_runner.setheading(90)
def left():
    maze_runner.setheading(180)
def down():
    maze_runner.setheading(270)
def move():
    maze_runner.forward(10)
    if(maze_runner.xcor() > 300 or maze_runner.xcor() < -300 or maze_runner.ycor() > 300 or maze_runner.ycor() < -300):
        maze_runner.write("You Win!", font=("Arial", 30, "normal"))
        time.sleep(5)
        exit()



#set up the maze
def maze_config():
    maze_turtle.pendown()
    maze_turtle.right(90)
    global current_wall_len

    #runs function according to the total number of walls
    for i in range (num_walls):
        current_wall_len = path_width*(i+1)

        #only run function if it's not hte first 4 walls because the length of the door and barrier are too long
        if (i > 4):
            door = r.randint(path_width*2, current_wall_len-(path_width*2))
            barrier = r.randint(path_width*2, current_wall_len-(path_width*2))
            maze_turtle.left(90)

            #in case the door and barrier are in the same place, change the cords of the barrier
            if (abs(door - barrier) < path_width*2):
                barrier = r.randint(path_width, current_wall_len-(path_width*2))

            #if the door is before the barrier, draw the door first
            if (door < barrier):
                draw_door(door)
                draw_barrier(barrier - door - door_len)
                #moves turtle forward minus the space already moved by the door and barrier
                maze_turtle.forward(current_wall_len - barrier)

            #if the door is after the barrier, draw the barrier first
            else:
                draw_barrier(barrier)
                draw_door(door - barrier)
                #moves turtle forward minus the space already moved by door and barrier
                maze_turtle.forward(current_wall_len - door - door_len)

#function to draw the door at the given position
def draw_door(pos):
    maze_turtle.pendown()
    maze_turtle.forward(pos)
    maze_turtle.penup()
    maze_turtle.forward(door_len)
    maze_turtle.pendown()

#function to draw the barrier at the given position
def draw_barrier(pos):
    maze_turtle.forward(pos)
    maze_turtle.left(90)
    maze_turtle.forward(path_width*2)
    maze_turtle.backward(path_width*2)
    maze_turtle.right(90)
    

#----------main----------
maze_config()

#keep turtle screen open
wn = t.Screen()
#onkeypress and listen

wn.onkeypress(up, "Up")
wn.onkeypress(left, "Left")
wn.onkeypress(right, "Right")
wn.onkeypress(down, "Down")
wn.onkeypress(move, "space")   
wn.listen()
wn.mainloop()

